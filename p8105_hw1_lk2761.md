p8105\_hw1\_lk2761
================
Lorraine Kwok
2019-09-16

## Problem 1

This code chunk is used to create a data frame that consists of four
different variables.

``` r
sample_df = tibble(
  sample = rnorm(8),
  gr_th_0 = sample > 0, 
  vec_char_8 = c("This", "generates", "a", "sample", "of", "eight", "random", "numbers"),
  vec_factor_8 = factor(c("odd", "even", "prime", "even", "prime", "even", "odd", "even"))
)
```

Now I will take the mean of each variable in the data
    frame.

``` r
mean(pull(sample_df, sample))
```

    ## [1] -0.04588

``` r
mean(pull(sample_df, gr_th_0)) 
```

    ## [1] 0.25

``` r
mean(pull(sample_df, vec_char_8))
```

    ## Warning in mean.default(pull(sample_df, vec_char_8)): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

``` r
mean(pull(sample_df, vec_factor_8))
```

    ## Warning in mean.default(pull(sample_df, vec_factor_8)): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

The mean can be calculated for the random sample and logical variables.
It cannot be calculated for the character or factor variables.

The following code chunk uses **as.numeric** to convert the logical,
character and factor variables from the sample\_df data frame to numeric
variables.The code chunk is shown but the output is not.

``` r
as.numeric(pull(sample_df, gr_th_0))
as.numeric(pull(sample_df, vec_char_8))
```

    ## Warning: NAs introduced by coercion

``` r
as.numeric(pull(sample_df, vec_factor_8))
```

When the **as.numeric** function is applied to the logical variable,
**gr\_th\_0**, the “true/false” dichotomy is converted to “0/1.” This
explains why it was possible for the mean to be calculated for
**gr\_th\_0**. When the function is applied to the character
vector,**vec\_char\_8**, a warning message appears and reports that NAs
were introduced by coercion. I think this occurred because the character
vector consists of text that is different for each “level.” This
explains why the mean of **vec\_char\_8** could not be calculated - the
values within this vector are not numeric. When the **as.numeric**
function is applied to the factor level,**vec\_factor\_8**, the three
different factor “levels” are converted into numbers. However, this does
not explain why the mean for **vec\_factor\_8** could not be calculated.

The following code chunk is used to:

  - Convert the logical vector to a numeric vector

  - Convert the logical vector to a factor vector

  - Convert the logical vector to a factor vector and then to a numeric
    vector

After each conversion, the random sample will be multipled by that
result.

``` r
gr_th_0_numeric = as.numeric(pull(sample_df, gr_th_0))
gr_th_0_numeric*pull(sample_df, sample)
```

    ## [1] 1.012828 0.000000 0.000000 0.000000 0.000000 0.000000 1.129448 0.000000

``` r
gr_th_0_factor = as.factor(pull(sample_df, gr_th_0))
gr_th_0_factor*pull(sample_df, sample)
```

    ## Warning in Ops.factor(gr_th_0_factor, pull(sample_df, sample)): '*' not
    ## meaningful for factors

    ## [1] NA NA NA NA NA NA NA NA

``` r
gr_th_0_factor_2 = as.factor(pull(sample_df, gr_th_0))
gr_th_0_numeric_2 = as.numeric(gr_th_0_factor_2)
gr_th_0_numeric_2*pull(sample_df, sample)
```

    ## [1]  2.0256560 -0.5879194 -0.5658592 -0.6593426 -0.3751442 -0.1893268
    ## [7]  2.2588965 -0.1317239

## Problem 2

This problem focuses on inline R code and plotting.

I am creating a data frame that consists of five variables.

``` r
plot_df = tibble(
  x = rnorm(500),
  y = rnorm(500),
  gr_th_1 = x + y > 1,
  gr_th_1_num = as.numeric(gr_th_1),
  gr_th_1_fac = as.factor(gr_th_1)
)
```

The size of the dataset is 500 by 5.

The mean of x is 0.0175149.

The median of x is 0.0639242.

The standard deviation of x is 1.0272107.

This code chunk makes a scatterplot of y vs. x. The first scatterplot
consists of color points using the logical variable, **gr\_th\_1**,
which indicates whether x + y is greater than 1. In this scatterplot,
the coral represents “False” and the blue represents “True.” The second
scatterplot uses the numeric variable, **gr\_th\_1\_num**, for color
points. In this scatterplot, the legend shows a blue gradient but the
plot itself only consists of two colors: the dark blue represents “0,”
which is the numeric equivalent to “False,” and the light blue
represents “1” which is the numeric equivalent to “True.” The third
scatterplot uses the factor variable, **gr\_th\_1\_fac**, for color
points. In this scatterplot, the coral represents “False” and the blue
represents
“True.”

``` r
ggplot(plot_df, aes(x = x, y = y, color = gr_th_1)) + geom_point()
```

![](p8105_hw1_lk2761_files/figure-gfm/create%20scatterplot-1.png)<!-- -->

``` r
ggsave("hw1_scatterplot_lk2761.pdf", plot = last_plot())
```

    ## Saving 7 x 5 in image

``` r
ggplot(plot_df, aes(x = x, y = y, color = gr_th_1_num)) + geom_point()
```

![](p8105_hw1_lk2761_files/figure-gfm/create%20scatterplot-2.png)<!-- -->

``` r
ggplot(plot_df, aes(x = x, y = y, color = gr_th_1_fac)) + geom_point()
```

![](p8105_hw1_lk2761_files/figure-gfm/create%20scatterplot-3.png)<!-- -->
