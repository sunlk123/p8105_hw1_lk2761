---
title: "p8105_hw1_lk2761"
author: "Lorraine Kwok" 
date: 2019-09-16
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Problem 1

This code chunk is used to create a data frame that consists of four different variables.

```{r create data frame for problem 1}
sample_df = tibble(
  sample = rnorm(8),
  gr_th_0 = sample > 0, 
  vec_char_8 = c("This", "generates", "a", "sample", "of", "eight", "random", "numbers"),
  vec_factor_8 = factor(c("odd", "even", "prime", "even", "prime", "even", "odd", "even"))
)
```

Now I will take the mean of each variable in the data frame. 

```{r taking mean of each variable in the data frame}
mean(pull(sample_df, sample))
mean(pull(sample_df, gr_th_0)) 
mean(pull(sample_df, vec_char_8))
mean(pull(sample_df, vec_factor_8))
```

The mean can be calculated for the random sample and logical variables. It cannot be calculated for the character or factor variables. 

The following code chunk uses **as.numeric** to convert the logical, character and factor variables from the sample_df data frame to numeric variables.The code chunk is shown but the output is not.  

```{r results = "hide"}
as.numeric(pull(sample_df, gr_th_0))
as.numeric(pull(sample_df, vec_char_8))
as.numeric(pull(sample_df, vec_factor_8))
```

When the **as.numeric** function is applied to the logical variable, **gr_th_0**, the "true/false" dichotomy is converted to "0/1." This explains why it was possible for the mean to be calculated for **gr_th_0**. When the function is applied to the character vector,**vec_char_8**, a warning message appears and reports that NAs were introduced by coercion. I think this occurred because the character vector consists of text that is different for each "level." This explains why the mean of **vec_char_8** could not be calculated - the values within this vector are not numeric. When the **as.numeric** function is applied to the factor level,**vec_factor_8**, the three different factor "levels" are converted into numbers. However, this does not explain why the mean for **vec_factor_8** could not be calculated. 

The following code chunk is used to: 

  * Convert the logical vector to a numeric vector
  
  * Convert the logical vector to a factor vector
  
  * Convert the logical vector to a factor vector and then to a numeric vector

After each conversion, the random sample will be multipled by that result. 

```{r converting logical vector to other variable types}
gr_th_0_numeric = as.numeric(pull(sample_df, gr_th_0))
gr_th_0_numeric*pull(sample_df, sample)

gr_th_0_factor = as.factor(pull(sample_df, gr_th_0))
gr_th_0_factor*pull(sample_df, sample)

gr_th_0_factor_2 = as.factor(pull(sample_df, gr_th_0))
gr_th_0_numeric_2 = as.numeric(gr_th_0_factor_2)
gr_th_0_numeric_2*pull(sample_df, sample)
```

## Problem 2

This problem focuses on inline R code and plotting. 

I am creating a data frame that consists of five variables. 

```{r creating data frame}
plot_df = tibble(
  x = rnorm(500),
  y = rnorm(500),
  gr_th_1 = x + y > 1,
  gr_th_1_num = as.numeric(gr_th_1),
  gr_th_1_fac = as.factor(gr_th_1)
)
```

The size of the dataset is `r nrow(plot_df)` by `r ncol(plot_df)`.

The mean of x is `r mean(pull(plot_df,x))`.

The median of x is `r median(pull(plot_df,x))`.

The standard deviation of x is `r sd(pull(plot_df,x))`.

This code chunk makes a scatterplot of y vs. x. The first scatterplot consists of color points using the logical variable, **gr_th_1**, which indicates whether x + y is greater than 1. In this scatterplot, the coral represents "False" and the blue represents "True." The second scatterplot uses the numeric variable, **gr_th_1_num**, for color points. In this scatterplot, the legend shows a blue gradient but the plot itself only consists of two colors: the dark blue represents "0," which is the numeric equivalent to "False," and the light blue represents "1" which is the numeric equivalent to "True." The third scatterplot uses the factor variable, **gr_th_1_fac**, for color points. In this scatterplot, the coral represents "False" and the blue represents "True." 

```{r create scatterplot}
ggplot(plot_df, aes(x = x, y = y, color = gr_th_1)) + geom_point()
ggsave("hw1_scatterplot_lk2761.pdf", plot = last_plot())

ggplot(plot_df, aes(x = x, y = y, color = gr_th_1_num)) + geom_point()

ggplot(plot_df, aes(x = x, y = y, color = gr_th_1_fac)) + geom_point()
```

