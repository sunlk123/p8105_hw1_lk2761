---
title: "p8105_hw1_lk2761"
author: "Lorraine Kwok" 
date: 2019-09-16
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Problem 1

This code chunk is used to create a data frame that consists of four different variables.

```{r create data frame for problem 1}

sample_df = tibble(
  sample = rnorm(8),
  gr_th_0 = sample > 0, 
  vec_char_8 = c("This", "generates", "a", "sample", "of", "eight", "random", "numbers"),
  vec_factor_8 = factor(c("odd", "even", "prime", "even", "prime", "even", "odd", "even"))
  
)

```

Now we will take the mean of each variable in the data frame. 

```{r taking mean of each variable in the data frame}
mean(pull(sample_df, sample))

mean(pull(sample_df, gr_th_0)) 

mean(pull(sample_df, vec_char_8))

mean(pull(sample_df, vec_factor_8))

```

The mean can be calculated for the random sample and logical variables. It cannot be calculated for the character or factor variables. 

The following code chunk uses **as.numeric** to convert the logical, character and factor variables from the sample_df data frame to numeric variables.The code chunk is shown but the output is not.  

```{r results = "hide"}

as.numeric(pull(sample_df, gr_th_0))
as.numeric(pull(sample_df, vec_char_8))
as.numeric(pull(sample_df, vec_factor_8))

```

When the **as.numeric** function is applied to the logical variable, **gr_th_0**, the "true/false" dichotomy is converted to "0/1." This explains why it was possible for the mean to be calculated for **gr_th_0**. When the function is applied to the character vector,**vec_char_8**, a warning message appears and reports that NAs were introduced by coercion. I think this occurred because the character vector consists of text that is different for each "level." This explains why the mean of **vec_char_8** could not be calculated - the values within this vector are not numeric. When the **as.numeric** function is applied to the factor level,**vec_factor_8**, the three different factor "levels" are converted into numbers. However, this does not explain why the mean for **vec_factor_8** could not be calculated. 

The following code chunk is used to: 

  * Convert the logical vector to a numeric vector
  
  * Convert the logical vector to a factor vector
  
  * Convert the logical vector to a factor vector and then to a numeric vector

After each conversion, the random sample will be multipled by that result. 

```{r converting logical vector to other variable types}

gr_th_0_numeric = as.numeric(pull(sample_df, gr_th_0))
gr_th_0_numeric*pull(sample_df, sample)

gr_th_0_factor = as.factor(pull(sample_df, gr_th_0))
gr_th_0_factor*pull(sample_df, sample)

gr_th_0_factor_2 = as.factor(pull(sample_df, gr_th_0))
gr_th_0_numeric_2 = as.numeric(gr_th_0_factor_2)
gr_th_0_numeric_2*pull(sample_df, sample)

```

